{"componentChunkName":"component---src-templates-generic-template-tsx","path":"/internationalization/getting-started/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"order\": 2\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Getting Started\"), mdx(\"p\", null, \"Let\\u2019s get started with a simple example using the internationalization capabilities of this framework. To set up a project with i18n, we\\u2019ll follow these steps:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Define a set of translations using the ftl syntax specified by Project Fluent. Documentation on ftl syntax can be found \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://projectfluent.org/fluent/guide/\"\n  }), \"here\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Extend the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BaseI18nController\"), \" class. We will need to override the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"load\"), \" method to tell the controller where to get the translations from, and which translations to use.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Use the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"I18nProvider\"), \" component (default export) at the top level of the application and give the controller object to this component. This will give the application the ability to utilize the controller and the i18n components to achieve internationalization throughout the app.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Use the provided internationalization components such as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"I18nSection\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"I18nText\"), \" to render translatable text in the application. We\\u2019ll use these components to tell the controller which translations we need and where to pull them from.\")), mdx(\"h2\", null, \"Defining Translations\"), mdx(\"p\", null, \"Project Fluent designed a simple, powerful syntax for writing translations for internationalization. This project makes use of that syntax, and expects translations to use that syntax. Again, if you are not familiar with the ftl syntax, please take the time to read about it \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://projectfluent.org/fluent/guide/\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"Now, let\\u2019s put that syntax to use:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// en/global.js\\nexport default `\\nwelcome-message = Welcome, { $user }!`\\n\\n// en/accounts.js\\nexport default `\\naccounts__welcome-message = Welcome to the accounts page, { $user }!`\\n\\n// es/global.js\\nexport default `\\nwelcome-message = \\xA1Bienvenido, { $user }!`\\n\\n// es/accounts.js\\nexport default `\\naccounts__welcome-message =\\n  \\xA1Bienvenido a la p\\xE1gina de cuentas, { $user }!`\\n\")), mdx(\"p\", null, \"Notice that we put translations in two separate folders; one for English and one for Spanish. We also made \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"global.js\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"accounts.js\"), \". This is because of how the i18n framework utilizes sections for organization and efficiency. We\\u2019ll discuss that more later. For now, let\\u2019s move on to extending the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BaseI18nController\"), \" class.\"), mdx(\"h2\", null, \"Extending \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"BaseI18nController\")), mdx(\"p\", null, \"In order to use the internationalization features offered by Cactus Framework, we\\u2019ll need to extend the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BaseI18nController\"), \" class, so we can override the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load()\"), \" method. This method will need to load ftl translations based on language and section and return that content so that it can be used by the controller.\"), mdx(\"p\", null, \"Let\\u2019s see what this might look like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// i18nController.js\\nimport { BaseI18nController } from '@repay/cactus-i18n'\\n\\nclass I18nController extends BaseI18nController {\\n async load(args) {\\n    const { lang, section } = args\\n    // load ftl translations from the source\\n    const { default: ftl } = await import(`./locales/${lang}/${section}.ftl`)\\n    \\n    return [{ lang, ftl }]\\n    \\n  }\\n}\\n\\nconst controller = new I18nController({ defaultLang: 'en', supportedLangs: ['en', 'es'] })\\nexport default controller\\n\")), mdx(\"p\", null, \"In this example, we assume that the translations are stored locally in a folder called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"locales\"), \". We use the language and section to load the translations needed, and then return them. Now that we\\u2019ve extended the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BaseI18nController\"), \" class, we can start using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<I18nProvider />\"), \".\"), mdx(\"h2\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"<I18nProvider />\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nProvider\"), \" component is designed to be a top-level wrapper component that can provide all of its children (the rest of the application) with the means to make internationalization happen. Let\\u2019s see how this would look:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// index.js\\nimport I18nProvider from '@repay/cactus-i18n'\\nimport i18nController from './i18nController.js'\\n\\nconst mainComponent = () => {\\n  return (\\n    <I18nProvider controller={i18nController} lang=\\\"en\\\">\\n      ...\\n    </I18nProvider>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Here, we make \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<I18nProvider />\"), \" the top-level component in our app, and we provide it with an instantiated object of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nController\"), \" class that we set up earlier. Providing this component with the controller using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"controller\"), \" prop will allow us to use i18n features. Now, let\\u2019s start using some other tools to display some text.\"), mdx(\"h2\", null, \"Using I18n Components\"), mdx(\"p\", null, \"Now that our setup is complete, we can add on to the work we did in the last step to render some translations. We\\u2019ll use two extra components: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nSection\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nText\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nSection\"), \" can be used to tell the controller which section to load (In this case, we have either \\u201Cglobal\\u201D or \\u201Caccounts\\u201D). If you don\\u2019t use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nSection\"), \" to specify a section to choose a translation from, the controller will use the \\u201Cglobal\\u201D translations. Let\\u2019s add on to what we did in the previous step with some examples.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// index.js\\n...\\nconst mainComponent = () => {\\n  return (\\n    <I18nProvider controller={i18nController} lang=\\\"en\\\">\\n      <I18nText get=\\\"welcome-message\\\" args={{ user: \\\"CS Human\\\" }} />\\n    </I18nProvider>\\n  )\\n} // Welcome, CS Human!\\n\")), mdx(\"p\", null, \"Notice that we told \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nText\"), \" that we wanted to get the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"welcome-message\"), \" translation, but we didn\\u2019t use an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nSection\"), \" component. This means the controller will look for the global translation. We also made use of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args\"), \" prop to pass an object that contains the value for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"user\"), \" variable in the translation. But what if we had used a section? Let\\u2019s check it out:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// index.js\\n...\\nconst mainComponent = () => {\\n  return (\\n    <I18nProvider controller={i18nController} lang=\\\"en\\\">\\n      <I18nSection name=\\\"accounts\\\">\\n        <I18nText get=\\\"welcome-message\\\" args={{ user: \\\"CS Human\\\" }} />\\n      </I18nSection>\\n    </I18nProvider>\\n  )\\n} // Welcome to the accounts page, CS Human!\\n\")), mdx(\"p\", null, \"Notice that we used the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get\"), \" value on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nText\"), \", but by making the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nText\"), \" component as a child of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nSection\"), \", we told the controller that we should be loading translations for the \\u201Caccounts\\u201D section, instead of global, the library then merges the section name and the get key to find the scopped message under \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"accounts__welcome-message\"), \". What if we wanted to load translations for a different language, though? To do so, we\\u2019ll just need to change the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lang\"), \" prop on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I18nProvider\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// index.js\\n...\\nconst mainComponent = () => {\\n  return (\\n    <I18nProvider controller={i18nController} lang=\\\"es\\\">\\n      <I18nSection name=\\\"accounts\\\">\\n        <I18nText get=\\\"welcome-message\\\" args={{ user: \\\"CS Human\\\" }} />\\n      </I18nSection>\\n    </I18nProvider>\\n  )\\n} // \\xA1Bienvenido a la p\\xE1gina de cuentas, CS Human!\\n\")), mdx(\"p\", null, \"At this point, we have successfully set up a small example with the ability to render different translations for different sections. If you want to see a working example, you can check out the standard implementation \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/repaygithub/cactus/tree/master/examples/standard\"\n  }), \"here\"), \". It uses a lot of these same ideas. Additionally, we have much more detailed API docs on each tool available with internationalization \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"internationalization/api-documentation/\"\n  }), \"here\")));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"title":"Getting Started","slug":"/internationalization/getting-started/"}}},"pageContext":{"slug":"/internationalization/getting-started/"}},"staticQueryHashes":["3276690975"]}