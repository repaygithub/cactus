{
    "componentChunkName": "component---src-templates-generic-template-tsx",
    "path": "/forms/api-documentation/",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"API Docs\",\n  \"order\": 3\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Cactus Form API Documentation\"), mdx(\"p\", null, \"For the most part you can just use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://final-form.org/docs/react-final-form/getting-started\"\n  }, \"React Final Form\"), \"\\nas it\\u2019s documented, substituting our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" component for theirs.\\nWe also add two new components:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DependentField\"), \" is like a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Field\"), \", but takes a set of field names and a callback to use when any of those fields changes.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FieldSpy\"), \" is analagous to \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://final-form.org/docs/react-final-form/api/FormSpy\"\n  }, \"FormSpy\"), \", but for a single field.\")), mdx(\"h2\", null, \"Field\"), mdx(\"p\", null, \"Takes the same arguments, with the same meaning as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://final-form.org/docs/react-final-form/api/Field\"\n  }, \"React Final Form\\u2019s version\"), \".\\nLike the original, it \\u201Cconsumes\\u201D all the props related to field configuration and forwards all other props to its component/render func.\\nIn particular, note that these forwarded props can override the input props,\\nlike \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onBlur\"), \", which will interfere with how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"final-form\"), \" works;\\nif you pass overrides, make sure you know how to register the changes you want with the form API.\\nIt also has two additional props:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"getFieldComponent\"), \" should be a function that accepts the props object and returns a valid component: either a string e.g. \\u201Cinput\\u201D or a functional or class component. It\\u2019s only called if no render function or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"component\"), \" prop is given, and is called \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"before\"), \" the base Field, so it doesn\\u2019t have access to any \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"final-form\"), \" data.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"processMeta\"), \" is a function that takes two arguments: the props (including the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"input\"), \" props from \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://final-form.org/docs/react-final-form/types/FieldRenderProps\"\n  }, \"the base Field\"), \" merged with the forwarded props), and the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"meta\"), \" object from the base Field. It should return a single object containing the final version of the props to be passed to the component/render func.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Note that although it\\u2019s not named as such \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"processMeta\"), \" does follow the rules of hooks, so you can use hooks in whatever function you pass here.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"One possibility is to use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React.useContext(I18nContext)\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@repay/cactus-i18n\"), \" to implement translated labels/error messages for your fields.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It also accepts an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"as\"), \" prop as an alias of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"component\"), \", to fit in better with all the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://styled-components.com/\"\n  }, \"styled-components\"), \" we use in Cactus Web.\")), mdx(\"p\", null, \"The biggest difference in the output is that all render methods receive the same props.\\nReact Final Form\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" passes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meta\"), \" to a render func or component,\\nbut if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"component\"), \" is a string it just merges the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" directly into the props and drops \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meta\"), \".\\nSince we allow customizing how the props are merged using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"processMeta\"), \",\\nwe just always merge the props into a single object and pass that to the component/render func\\nregardless of whether the component is an HTML element (string) or custom component.\"), mdx(\"h3\", null, \"Configuration\"), mdx(\"p\", null, \"Perhaps the most important difference to React Final Form\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" is the configuration of\\ndefaults for certain props, under the assumption that most fields in a project will work similarly.\\nThe configuration looks like this in Typescript:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// You can actually use any props accepted by `Field`, but these are the most useful to configure.\\ninterface FieldProps {\\n  getFieldComponent?: (props: Record<string, any>) => React.ElementType;\\n  // `FieldMetaState` is from React Final Form, ref `FieldRenderProps`.\\n  processMeta?: (props: Record<string, any>, meta: FieldMetaState) => Record<string, any>;\\n  // `FieldSubscription` is from Final Form, ref `registerField`.\\n  subscription?: FieldSubscription;\\n}\\n\\n// Sets new config options, and returns the old config.\\nField.configureDefaults = (defaults: FieldProps) => FieldProps\\n\\n// Creates a new component with the given defaults.\\nField.withDefaults = (defaults: FieldProps) => FunctionalComponent<FieldProps>\\n\\n// Returns the original config, as defined in the Cactus Form library.\\nField.initialDefaults = () => FieldProps\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialDefaults\"), \" is mostly provided so it can be extended without having to rewrite it entirely, and returns something like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Field.initialDefaults = () => ({\\n  subscription: {\\n    value: true,\\n    error: true,\\n    touched: true,\\n    submitError: true,\\n    modifiedSinceLastSubmit: true,\\n  },\\n\\n  // Note the commonalities between the subscription and what's used here.\\n  processMeta: (props, meta) => {\\n    const error = (meta.touched && meta.error) || (!meta.modifiedSinceLastSubmit && meta.submitError)\\n    if (error && !props.error) {\\n      props.error = error\\n    }\\n    return props\\n  },\\n\\n  getFieldComponent: (props) => {\\n    switch (props.type) {\\n      // Omitted for brevity: maps to Cactus Web, e.g. \\\"date\\\" -> DateInputField\\n      default:\\n        return TextInputField\\n    }\\n  },\\n})\\n\")), mdx(\"p\", null, \"Both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureDefaults\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withDefaults\"), \" work by setting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"defaultProps\"), \"\\nproperty on the function they\\u2019re attached to.\\nThe main difference is scope: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureDefaults\"), \" applies to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" component itself,\\nand thus applies to the entire project (including uses of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DependentField\"), \");\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withDefaults\"), \" makes a new component that can be used on a single form or type of form,\\nif it\\u2019s somewhat different than how forms normally behave on the site.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const FieldWithAlwaysVisibleErrors = Field.withDefaults({\\n  subscription: { value: true, error: true },\\n  processMeta: (props, { error }) => ({ error, ...props }),\\n})\\n\")), mdx(\"h3\", null, \"Validation\"), mdx(\"p\", null, \"One other default behavior that differs from the base Field is that if a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"required\"), \" prop is passed,\\nbut there is no \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validate\"), \" function, one will automatically be set.\\nIt basically checks that the value is not falsy or an empty array, though literal \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" are both allowed.\\nThis validator is also available separately:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import { validateRequired } from '@repay/cactus-form'\\n\")), mdx(\"p\", null, \"You can also define custom required error messages with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requiredMsg\"), \" prop. Both strings and React nodes are acceptable:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"<Field required requiredMsg=\\\"Required Field\\\" {...fieldProps} />\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"<Field required requiredMsg={<div>Required Field</div>} {...fieldProps} />\\n\")), mdx(\"p\", null, \"To use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"required\"), \" without the validator you\\u2019d need to pass an explicit \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validate\"), \" function, like a noop (or use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureDefaults\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withDefaults\"), \" to set a default validator or default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requiredMsg\"), \").\"), mdx(\"h3\", null, \"Refs & Extensions\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" component is explicitly defined as a functional component so it\\u2019s relatively easy to extend.\\nThat does mean, however, that you can\\u2019t pass a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \" prop to forward to the field.\\nThere are several ways around this, but probably the easiest two are a render func and a wrapper:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const withRenderFunc = (\\n  <Field {...propsWithoutRef}>\\n    {(props) => (\\n      <MyField {...props} ref={myRef} />\\n    })\\n  </Field>\\n)\\n// Note that you can just call `Field` as a normal function,\\n// which is more efficient than creating another level of the component tree.\\nconst FieldWithRef = React.forwardRef((props, ref) => Field({ ...props, ref }))\\n\")), mdx(\"h2\", null, \"DependentField\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DependentField\"), \" is actually an extenstion of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" as described in the last section.\\nIt creates a normal \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \", then uses Final Form\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"registerField\"), \" API to subscribe\\nto changes to the dependency fields.\\nThe extra props look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"interface DependentFieldProps extends FieldProps {\\n  dependsOn: string | string[] | Record<string, DependencyConfig>;\\n  onDependencyChange?: (state: FieldState, props: FieldProps) => void\\n}\\n\\ninterface DependencyConfig {\\n  // The basic field subscription format, e.g. `value: true`\\n  [K in keyof FieldSubscription]?: boolean\\n  onChange?: (state: FieldState, props: FieldProps) => void\\n}\\n\")), mdx(\"p\", null, \"It\\u2019s important to note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dependsOn\"), \" is used in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" hook to create the field subscriptions,\\nso to prevent unnecessary subscription turnover you should either use a constant or something like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \";\\nthat caveat does \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" apply to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onDependencyChange\"), \", however.\"), mdx(\"p\", null, \"If you pass the dependencies as a string or an array of field names, they will only subscribe\\nto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" changes and will all use the same change handler;\\nyou can still tell which field changed (for arrays) by looking at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state.name\"), \".\\nThe second dependency format allows more flexibility in the subscription and change handling.\"), mdx(\"p\", null, \"The first argument to the change handler is the state of the field being watched;\\nit\\u2019s the same as the state passed to the callback for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"registerField\"), \".\\nThe second argument is the merged props of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DependentField\"), \"; chances are the only\\none you\\u2019ll need is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \", which you can use to update the DependentField\\u2019s\\nvalue as the dependencies change.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const MyForm = (props) => (\\n  <Form {...props}>\\n    <Field name=\\\"power\\\" type=\\\"number\\\" />\\n    <DependentField name=\\\"reaction\\\" dependsOn=\\\"power\\\" onDependencyChange={\\n      (state, { onChange }) => {\\n        onChange(state.value > 9000 ? 'unbelievable' : 'still good')\\n      }\\n    } />\\n  </Form>\\n)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DependentField\"), \" also has the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureDefaults\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withDefaults\"), \" functions that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" has.\"), mdx(\"h2\", null, \"FieldSpy\"), mdx(\"p\", null, \"Basically the same as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://final-form.org/docs/react-final-form/api/FormSpy\"\n  }, \"FormSpy\"), \",\\nexcept for a single field. It also doesn\\u2019t support the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" prop that FormSpy has.\\nYou indicate which field to watch with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fieldName\"), \" prop:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const spyOn = { value: true }\\nconst MyForm = (props) => (\\n  <Form {...props}>\\n    <Field name=\\\"power\\\" type=\\\"number\\\" />\\n    <FieldSpy fieldName=\\\"power\\\" subscription={spyOn}>\\n      {({ value }) => (\\n        <span>You have selected a power level of {value}.</span>\\n      )}\\n    </FieldSpy>\\n  </Form>\\n)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"title":"API Docs","slug":"/forms/api-documentation/"}}},"pageContext":{"slug":"/forms/api-documentation/"}},
    "staticQueryHashes": ["3276690975"]}