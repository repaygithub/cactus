{"componentChunkName":"component---src-templates-generic-template-tsx","path":"/how-tos/forms/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"How to Write Cactus Forms Using Formik\"), mdx(\"p\", null, \"Collecting data using forms is one of the most basic functions of a website. \", mdx(\"a\", {\n    to: \"/components/\"\n  }, \"@repay/cactus-web\"), \" provides several styled form inputs, as well as a few custom inputs that emulate built-in HTML inputs. This guide will show you the basics of combining these input components with a common forms library, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://formik.org/\"\n  }, \"Formik\"), \".\"), mdx(\"p\", null, \"Before starting, you should have an application, and know how to add a page or component. The examples used will be based on an app like those created by the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/repaygithub/ui-tools/tree/master/modules/create-repay-ui\"\n  }, \"@repay/create-ui\"), \" package; see \", mdx(\"a\", {\n    to: \"/tutorials/responsive-web-design/\"\n  }, \"this tutorial\"), \" for an example with starting a new project.\"), mdx(\"h3\", null, \"Installation\"), mdx(\"p\", null, \"Installation is simple enough, just add the latest verstion of \\u201Cformik\\u201D to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dependencies\"), \" list in your package.json (or however you add dependencies in your particular project).\"), mdx(\"h2\", null, \"Using Formik\"), mdx(\"p\", null, \"There are two basic ways of using Formik: with components, and with hooks. We won\\u2019t be getting into all the arguments and subtleties since those are well-covered in the Formik documentation, just covering enough to show how it works with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@repay/cactus-web\"), \" components.\"), mdx(\"p\", null, \"Creating a form is simple by either method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import { Formik, useFormik }\\nimport React from 'react'\\n\\nimport { TextInputField } from '@repay/cactus-web'\\n\\nconst TestFormComponent = (props) => (\\n  <Formik {...props}>\\n    {({ handleSubmit, handleChange, values, touched, errors }) => (\\n      <form onSubmit={handleSubmit}>\\n        <TextInputField\\n          id=\\\"text-input\\\"\\n          name=\\\"mytext\\\"\\n          value={values.mytext}\\n          label=\\\"Enter some text\\\"\\n          error={touched.mytext && errors.mytext}\\n          onChange={handleChange}\\n        />\\n      </form>\\n    )}\\n  </Formik>\\n)\\n\\nconst TestFormHook = (props) => {\\n  const { handleSubmit, handleChange, values, touched, errors } = useFormik(props)\\n  return (\\n    <form onSubmit={handleSubmit}>\\n      <TextInputField\\n        name=\\\"mytext\\\"\\n        value={values.mytext}\\n        label=\\\"Enter some text\\\"\\n        error={touched.mytext && errors.mytext}\\n        onChange={handleChange}\\n      />\\n    </form>\\n  )\\n}\\n\")), mdx(\"p\", null, \"The main difference between the two is depth: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useFormik\"), \" does everything locally, while the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Formik\"), \" component (which in fact utilizes the hook internally) creates a React context which allows access to the formik helpers within sub-components via the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useFormikContext\"), \" hook (or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FormikConsumer\"), \" component).\"), mdx(\"p\", null, \"Finally, there are two other helper components we\\u2019ll be using within a Formik context:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Form\"), \" creates a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<form>\"), \" element and automatically adds the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"handleSubmit\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"handleReset\"), \" event handlers.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Field\"), \" creates an element and automatically adds the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"name\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"value\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"handleChange\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"handleBlur\"), \" props.\")), mdx(\"h2\", null, \"Formik & Cactus\"), mdx(\"p\", null, \"Cactus has two basic kinds of field components: regular HTML inputs that have simply been styled using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@repay/cactus-theme\"), \", and custom components that mimic regular HTML inputs. The former can be used pretty much like any other input with Formik (and there are plenty of examples in their docs):\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"CheckBox\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"CheckBoxField\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RadioButton\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RadioButtonField\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TextArea\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TextAreaField\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TextInput\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TextInputField\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Toggle\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ToggleField\"))), mdx(\"p\", null, \"The custom components are these:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ColorPicker\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DateInput\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DateInputField\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FileInput\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FileInputField\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RadioGroup\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Select\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SelectField\"))), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CheckBoxGroup\"), \" isn\\u2019t really a field, though it behaves a bit like one so we\\u2019ll cover it as well.\"), mdx(\"h3\", null, \"Field Examples\"), mdx(\"p\", null, \"For the rest of these examples, I\\u2019ll be omitting the form boilerplate for brevity; assume a similar basic Formik setup like the following (we\\u2019ll mostly be referencing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"formik\"), \" variable in the examples):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import { Field, Form, Formik }\\nimport React from 'react'\\n\\nimport { Button, [example component] } from '@repay/cactus-web'\\n\\nconst logValues = (values) => console.log(values)\\n\\nconst TestForm = (props) => (\\n  <Formik onSubmit={logValues} initialValues={{}} {...props}>\\n    {(formik) => (\\n      <Form>\\n        [example components]\\n        <Button type=\\\"submit>Submit</Button>\\n      </Form>\\n    )}\\n  </Formik>\\n)\\n\")), mdx(\"h4\", null, \"TextAreaField, TextInputField\"), mdx(\"p\", null, \"These are as basic as it gets; you can use them directly, or through the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" helper component.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"<TextAreaField\\n  name=\\\"largeText\\\"\\n  label=\\\"Lots of Text\\\"\\n  onChange={formik.handleChange}\\n  value={formik.values.largeText}\\n  error={formik.errors.largeText}\\n/>\\n<Field\\n  as={TextInputField}\\n  name=\\\"smallText\\\"\\n  label=\\\"One line\\\"\\n  error={formik.errors.smallText}\\n/>\\n\")), mdx(\"h4\", null, \"CheckBoxField, RadioButtonField, ToggleField\"), mdx(\"p\", null, \"These three are similar to the other basic fields, but there\\u2019s an important difference: their value is determined by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"checked\"), \" prop, not the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" prop.\\nIn order for Formik to set the values appropriately when using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \", you must set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" prop so it knows how to set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"checked\"), \" prop.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"<Field\\n  as={CheckBoxField}\\n  type=\\\"checkbox\\\"\\n  name=\\\"ready\\\"\\n  label=\\\"Are you Ready?\\\"\\n/>\\n<Field\\n  as={ToggleField}\\n  type=\\\"checkbox\\\"\\n  name=\\\"set\\\"\\n  label=\\\"Are you Set?\\\"\\n/>\\n<RadioButtonField\\n  name=\\\"yesOrNo\\\"\\n  value=\\\"yes\\\"\\n  label=\\\"Yes!\\\"\\n  checked={formik.values.yesOrNo === 'yes'}\\n  onChange={formik.handleChange}\\n/>\\n<Field\\n  as={RadioButtonField}\\n  type=\\\"radio\\\"\\n  name=\\\"yesOrNo\\\"\\n  value=\\\"no\\\"\\n  label=\\\"No!!\\\"\\n/>\\n\")), mdx(\"p\", null, \"With checkboxes (including Toggle) you can provide a non-boolean value (similar to how radio buttons work, but in a \\u201Cchoose one or more\\u201D kind of use case). In that case, Formik sets the value as a list and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"checked\"), \" prop based on whether or not the value is in the list. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note:\"), \" on some browsers, at least, checkboxes have a default value; thus, it\\u2019s recommended you \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" use the basic \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"formik.handleChange\"), \" function because it will incorrectly turn the checkbox value into a list. Either use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" helper, which handles the default value correctly, or write a custom change handler using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"formik.setFieldValue\"), \".\"), mdx(\"h4\", null, \"CheckBoxGroup\"), mdx(\"p\", null, \"Since CheckBoxGroup isn\\u2019t really a field, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" helper doesn\\u2019t work well with it. It \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"can\"), \" be used to wrap the individual checkboxes, especially if they all have different names and/or boolean values. However, if \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"all\"), \" the checkboxes have non-boolean values, you only need to pass the change/blur handlers at the top level (even if they have different names).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"<CheckBoxGroup\\n  name=\\\"zeroOrMore\\\"\\n  label=\\\"Choose Zero or More\\\"\\n  onChange={formik.handleChange}\\n  onBlur={formik.handleBlur}\\n>\\n  <CheckBoxGroup.Item\\n    name=\\\"zeroOrMore\\\"\\n    label=\\\"Zero\\\"\\n    value=\\\"zero\\\"\\n    checked={formik.values.zeroOrMore?.includes?.('zero')}\\n  />\\n  {/* In real code you probably shouldn't mix these methods. */}\\n  <Field\\n    as={CheckBoxGroup.Item}\\n    type=\\\"checkbox\\\"\\n    name=\\\"conjunction\\\"\\n    label=\\\"OR\\\"\\n  />\\n  <CheckBoxGroup.Item\\n    name=\\\"zeroOrMore\\\"\\n    label=\\\"More\\\"\\n    value=\\\"more\\\"\\n    checked={formik.values.zeroOrMore?.includes?.('more')}\\n  />\\n</CheckBoxGroup>\\n\")), mdx(\"p\", null, \"If all the child checkboxes have different names \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" boolean values, you can take a different shortcut to set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"checked\"), \" prop:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"<CheckBoxGroup\\n  name=\\\"shortcuts\\\"\\n  label=\\\"Shortcuts\\\"\\n  onChange={(e) => formik.setFieldValue(e.target.name, e.target.checked)}\\n  checked={formik.values}\\n>\\n  <CheckBoxGroup.Item name=\\\"one\\\" label=\\\"One\\\" />\\n  <CheckBoxGroup.Item name=\\\"two\\\" label=\\\"Two\\\" />\\n</CheckBoxGroup>\\n\")), mdx(\"h4\", null, \"ColorPicker, DateInputField, FileInputField, RadioGroup, SelectField\"), mdx(\"p\", null, \"These fields are all custom components rather than styled HTML elements, but their \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" props are designed to work with Formik as if they were regular text inputs. The important thing is to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" prop: with no type prop, Formik will just take \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"event.target.value\"), \" from the change event, and pass it as-is to the component\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" prop.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"{/* Note that AccessibleField forwards `name` to its child. */}\\n<AccessibleField\\n  name=\\\"surprise\\\"\\n  label=\\\"Color Me Surprised\\\"\\n  error={formik.errors.surprise}\\n>\\n  <Field as={ColorPicker} />\\n</AccessibleField>\\n<DateInputField\\n  name=\\\"when\\\"\\n  label=\\\"When was it?\\\"\\n  onChange={formik.handleChange}\\n  value={formik.values.when}\\n  error={formik.errors.when}\\n/>\\n<Field\\n  as={FileInputField}\\n  name=\\\"theFiles\\\"\\n  label=\\\"Add the Files\\\"\\n  error={formik.errors.theFiles}\\n/>\\n<SelectField\\n  name=\\\"chooseOne\\\"\\n  label=\\\"Choose One\\\"\\n  options={['chosen', 'value', 'options']}\\n  onChange={formik.handleChange}\\n  value={formik.values.chooseOne}\\n/>\\n<Field\\n  as={RadioGroup}\\n  name=\\\"chooseOneAgain\\\"\\n  label=\\\"Choose Another One\\\"\\n  error={formik.errors.chooseOneAgain}\\n>\\n  <RadioGroup.Button label=\\\"English\\\" value=\\\"English\\\" />\\n  <RadioGroup.Button label=\\\"French\\\" value=\\\"French\\\" />\\n  <RadioGroup.Button label=\\\"German\\\" value=\\\"German\\\" />\\n</Field>\\n\")), mdx(\"h3\", null, \"Further Reading\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://formik.org/docs/tutorial\"\n  }, \"Formik Documentation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    to: \"/components/\"\n  }, \"@repay/cactus-web Documentation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/repaygithub/cactus/tree/master/examples/mock-ebpp\"\n  }, \"Example app w/ form (UI Config page)\"))));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"title":"How to Write Cactus Forms Using Formik","slug":"/how-tos/forms/"}}},"pageContext":{"slug":"/how-tos/forms/"}},"staticQueryHashes":["3276690975"]}