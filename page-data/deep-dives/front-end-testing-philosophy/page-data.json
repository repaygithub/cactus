{"componentChunkName":"component---src-templates-generic-template-tsx","path":"/deep-dives/front-end-testing-philosophy/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Front End Testing Philosophy\"), mdx(\"h2\", null, \"Why Are Tests Important?\"), mdx(\"p\", null, \"Writing tests is such an important step in the software development process because it increases confidence in your code. We write tests so that we can rest assured that an application will work as intended when it\\u2019s used.\"), mdx(\"h2\", null, \"What Types of Tests Are There?\"), mdx(\"p\", null, \"Kent C. Dodds lists the types of tests and what they are used for in his article on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kentcdodds.com/blog/unit-vs-integration-vs-e2e-tests\"\n  }, \"types of front end testing\"), \". For the purposes of this discussion, we will be focusing on unit, integration, and end to end tests.\"), mdx(\"p\", null, \"As mentioned Dodds\\u2019 article linked above, the different types of tests are defined as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unit Tests: Verify that an individual component/function works as intended on its own.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Integration Tests: Verify that multiple units work together.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"End to End Tests: Test behaves like a user and navigates an application in the same way that a normal user would to ensure that the app functions correctly as a whole.\")), mdx(\"h2\", null, \"What Tests Should You Write?\"), mdx(\"p\", null, \"In general, we recommend that you follow Kent C. Dodds\\u2019 guides on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kentcdodds.com/blog/write-tests\"\n  }, \"writing tests\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kentcdodds.com/blog/how-to-know-what-to-test\"\n  }, \"how to know what to test\"), \".\"), mdx(\"p\", null, \"To summarize, when testing a front end application, you should focus more on covering use cases than increasing code coverage. Your code coverage metric will increase as a by-product of use case testing. When writing a test, you should be thinking of all of the possible ways that a piece of code could respond given its inputs. What will the function return if you pass a certain argument? What happens if you don\\u2019t pass any arguments at all? What happens if a user clicks on some button, or enters some text in a field? What should a component render given a certain set of props? These are questions that you should be asking yourself when writing tests, and if you are writing your tests to answer these types of questions, then you are focused on the use cases, and this will yield a higher confidence in your code.\"), mdx(\"h3\", null, \"End to End Tests\"), mdx(\"p\", null, \"According to Dodds, you should ask yourself a simple question when determining what code to write tests for: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"What part of this app would make me most upset if it were broken?\"), \" He suggests making a list of features that your application supports and to prioritize them. When you have that list, try to write a single E2E test to cover the \\u201Chappy path\\u201D that a user would go through for a given use case. Doing so will often cover many of the features that you listed as the most important. End to end tests can be very lengthy and can take a long time to run, but the tradeoff is that E2E tests will give you the most confidence that your application is behaving as it should. There are several tools to help with writing E2E tests, and we recommend using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://devexpress.github.io/testcafe/\"\n  }, \"TestCafe\"), \" with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://testing-library.com/docs/testcafe-testing-library/intro\"\n  }, \"TestCafe Testing Library\"), \". For more info on setting up your E2E tests, check out our \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/cactus/how-tos/end-to-end-testing/\"\n  }, \"End to End Testing Guide\"), \". You can also find some good examples of E2E tests in the Channels application.\"), mdx(\"h3\", null, \"Integration Tests\"), mdx(\"p\", null, \"After you\\u2019ve set up a couple of end to end tests to cover the most important user paths, you should start looking at writing some integration tests. As Kent C. Dodds points out, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"most\"), \" of your tests should be targeting the integration of components. As such, so you should typically mock as little as possible here. You may render a full app in these tests, but you don\\u2019t have to. Remember to focus on testing use cases over increasing test coverage. We won\\u2019t dive into the specifics of how to write these tests here, but we recommend using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://jestjs.io/docs/en/getting-started\"\n  }, \"jest\"), \" with React Testing Library and following along with their \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://testing-library.com/docs/react-testing-library/setup/\"\n  }, \"setup docs\"), \". Feel free to browse our \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/repaygithub/cactus/tree/master/examples\"\n  }, \"example apps\"), \" to see some examples of good integration tests.\"), mdx(\"h3\", null, \"Unit Tests\"), mdx(\"p\", null, \"Once you have some integration tests in place, it\\u2019s time to start writing unit tests. A unit test should focus on testing a single piece of code, whether it be a component, a page, or a function. In these tests, you\\u2019ll want to mock out anything that doesn\\u2019t pertain to the piece of code you are testing. You should write unit tests for any code that contains complex business logic and, again, you should be focusing on testing the use case over ensuring 100% code coverage. We recommend using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://jestjs.io/docs/en/getting-started\"\n  }, \"jest\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://testing-library.com/docs/react-testing-library/intro/\"\n  }, \"React Testing Library\"), \" for unit tests. You can find some good examples of unit tests by browsing the components offered through \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/repaygithub/cactus/tree/master/modules/cactus-web/src\"\n  }, \"@repay/cactus-web\"), \".\"), mdx(\"h2\", null, \"Avoiding Implementation Details\"), mdx(\"p\", null, \"In Kent C Dodds\\u2019 article on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kentcdodds.com/blog/testing-implementation-details\"\n  }, \"testing implementation details\"), \", he points out that you should avoid testing the implementation details of a component because it can yield brittle tests that break when you refactor application code, or it can cause your tests to pass when you break application code.\"), mdx(\"h3\", null, \"What Are Implementation Details?\"), mdx(\"p\", null, \"Dodds\\u2019 defines implementation details as \\u201Cthings which users of your code will not typically see, or even know about.\\u201D In a React application, the users are both the end users, who will see and interact with whatever is rendered on the page, and the developers who will have access to the props. With that in mind, your tests should only interact with the props that are passed and the rendered output.\"), mdx(\"h3\", null, \"What\\u2019s The Solution?\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://testing-library.com/docs/\"\n  }, \"Testing Library\"), \"! This library provides you with the tools to test your code in the same way that a user would interact with the components in the UI. They offer several different frameworks so that you can use it with TestCafe, React, Puppeteer, and many other front end tools. Though they offer testing libraries that are compatible with many different frameworks, the idea is always the same: Query and interact with DOM nodes so that you can avoid interacting with the code\\u2019s internal implementation. Using Testing Library, you can query DOM elements that you expect to be rendered, and trigger mouse and keyboard events to better simulate an end user\\u2019s interaction. Testing Library makes it difficult to test your front end code the wrong way, so we highly recommend that you couple their tools with whatever framework you are working with in order to write meaningful, user-oriented tests.\"), mdx(\"h2\", null, \"Wrap Up\"), mdx(\"p\", null, \"Writing front end tests is important because it increases confidence in your application and helps ensure that your application is performing as you expect it to. It\\u2019s important to include multiple types of tests, from unit, to integration and all the way up to end to end tests to gain the most confidence in your code. You\\u2019ll also gain the most benefit from your tests if you focus on making sure that your use cases are covered rather than focusing more heavily on code coverage. When writing tests, use tools like Testing Library to avoid interacting with the internal code and instead simulate a user\\u2019s actions. If you\\u2019d like to learn more about front end testing in general, Kent C. Dodds is a great resource and he frequently posts articles relating to front end testing on his \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kentcdodds.com/blog/\"\n  }, \"blog\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"title":"Front End Testing Philosophy","slug":"/deep-dives/front-end-testing-philosophy/"}}},"pageContext":{"slug":"/deep-dives/front-end-testing-philosophy/"}},"staticQueryHashes":["3276690975"]}