{"componentChunkName":"component---src-templates-generic-template-tsx","path":"/components/hooks/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Hooks\",\n  \"order\": -99\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Hooks\"), mdx(\"h2\", null, \"useRefState\"), mdx(\"p\", null, \"This is functionally similar to React\\u2019s built-in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" hook;\\nhowever its return value is more similar to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useRef\"), \" hook in that it\\u2019s a stable\\nobject which always has the current state. It has two call signature overloads:\\none that takes the same args as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \", and one that takes the same args as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \".\\nThe ref returned by the function also has an attached \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setState\"), \" function, which\\nbehaves the same as the state setter/dispatch function returned by the React hooks,\\nwith one difference: it sets \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref.current\"), \" synchronously before triggering a re-render,\\nand returns the new state.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"function Component(props) {\\n  const ref = useRefState(42)\\n  React.useEffect(() => {\\n    const newState = ref.setState(13)\\n    // You can also just set the value directly\\n    // if you don't want to trigger a re-render.\\n    ref.current = newState + 7\\n  }, [])\\n  return <span {...props}>{ref.current}</span>\\n}\\n\")), mdx(\"h2\", null, \"useControllableValue\"), mdx(\"p\", null, \"Use this hook to manage state for a value that can either be controlled by props\\nor left as internal state, i.e. like an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<input>\"), \" element\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" prop.\\nThe return value is the same as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \": an array containing the current value\\n(either that passed in props, or the internal state value) and a dispatcher.\\nIf it pulls a value from props, it will update the internal state to match\\nduring the effect phase of the render cycle.\"), mdx(\"p\", null, \"It takes several arguments:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First is always an object containing component props.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Second can be one of two things:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A prop name: the state will be pulled from props, unless it\\u2019s undefined in which case the internal state is used.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An extractor function that takes two args: the props, and the internal state; and returns the new state.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Finally, it takes the args for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useState\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useReducer\"), \": either an initial value, or a reducer + initial arg + initializer function.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type UseControllableValue = <Props, State, Action>(\\n  props: Props,\\n  key: keyof Props | ((p: Props, s: State) => State),\\n  ...args: Parameters<typeof useState> | Parameters<typeof useReducer>\\n): [State, Dispatch<State, Action>]\\n\")), mdx(\"p\", null, \"It uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useRefState\"), \" under the hood, so the dispatcher is synchronous and\\nreturns the new state, in case you need it to raise an event.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"function SimpleInput({ onChange, ...props }) {\\n  const [value, setValue] = useControllableValue(props, 'value', props.defaultValue)\\n  const handleChange = (event) => {\\n    const newValue = setValue(event.target.value)\\n    onChange(newValue)\\n  }\\n  return <input {...props} value={value} onChange={handleChange} />\\n}\\n\")), mdx(\"h2\", null, \"useScrollTrap\"), mdx(\"p\", null, \"In the case you have a popup, modal, or drop-down with it\\u2019s own scrolling context, you often want to prevent scrolling from propagating up to the main page: it can be disconcerting when you\\u2019re scrolling in a drop-down and suddenly the entire page is moving. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useScrollTrap\"), \" takes in a ref to a scrollable HTML element (an element styled with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overflow: auto\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overflow: scroll\"), \") and ensures scrolling doesn\\u2019t \\u201Cescape\\u201D.\"), mdx(\"p\", null, \"There are two caveats in browsers that don\\u2019t support the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overscroll-behavior\"), \" CSS property:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The Javascript backup is only implemented for vertical scrolling.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The Javascript backup is based on the \\u201Cwheel\\u201D event, since (to my knowledge) other methods of scrolling don\\u2019t propagate.\")), mdx(\"p\", null, \"For situations where a hook isn\\u2019t appropriate, or if you have more complex logic about how to apply the scroll trap, there\\u2019s a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"trapScroll\"), \" function with the same arguments: it will either return nothing for the CSS implementation, or a \\u201Ccleanup\\u201D function for the backup implementation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"function ScrollTrap(props) {\\n  const ref = useRef()\\n  useScrollTrap(ref)\\n  // Is equivalent to:\\n  // useEffect(() => trapScroll(ref), [ref])\\n  return <div {...props} ref={ref} style={{ overflow: 'auto' }} />\\n}\\n\")), mdx(\"h2\", null, \"usePopup\"), mdx(\"p\", null, \"This hook is designed to help set up popup menus & dialogs, or basically any situation where it\\u2019s appropriate to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"aria-haspopup\"), \" attribute. It provides helpers for opening/closing, and for managing the focus of elements within the popup.\"), mdx(\"p\", null, \"It\\u2019s expected that the popup will consist of at least two, preferably three elements: a button to toggle visibility (required); a div or other block element to serve as the popup (required); and a div to serve as a wrapper around the two (recommended). The wrapper semantically groups the button and popup as a unit, and handles events that bubble up from either, so it\\u2019s much more convenient to have one than not.\"), mdx(\"p\", null, \"Styling these elements is of course up to the developer, but generally speaking the wrapper should be unstyled, or in other words, the button should look the same whether or not the wrapper is there. The popup will usually use absolute or fixed positioning, and should control visibility using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"aria-hidden\"), \" attribute, using a CSS rule like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-css\"\n  }, \".my-popup-class {\\n  display: block;\\n}\\n.my-popup-class[aria-hidden] {\\n  display: none;\\n}\\n\")), mdx(\"h3\", null, \"Arguments\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"usePopup\"), \" hook has one required argument and several options:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const popup = usePopup(popupType, { ...options })\\n\")), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Arg\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Required\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"popupType\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Y\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Must be a valid value for the \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"aria-haspopup\"), \" attribute\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"id\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The HTML ID for the wrapper\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"popupId\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The HTML ID for the popup; if nothing is passed, an ID will be generated\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"buttonId\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The HTML ID for the button; if nothing is passed, an ID will be generated\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"onWrapperBlur\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"function\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"See below\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"onWrapperKeyDown\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"function\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"See below\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"onButtonClick\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"function\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"See below\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"onButtonKeyDown\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"function\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"See below\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"positionPopup\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"function\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Callback used to tweak popup\\u2019s position styles\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"focusControl\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"function\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Callback used to manage focus within the popup\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"initialExpanded\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Whether the popup is initially visible; default false\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"focusOnClickExpand\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"N\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Whether clicking the button will move focus to the popup; default true for \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"popupType=dialog\"), \", else false\")))), mdx(\"p\", null, \"The event handlers correspond to the handlers returned by the hook, to make it easier to combine the default handlers with custom behavior: the default handlers run first and then call the optional handlers. In addition to the normal \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"event\"), \" argument, they can also take as a second argument the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"toggle\"), \" function, described in the Return Value section below.\"), mdx(\"h4\", null, \"Callbacks\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"positionPopup\"), \" is called each time the popup becomes visible, in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useLayoutEffect\"), \" hook. The first parameter is the popup div itself, and the second is the toggle button. Ideally, positioning styles can be determined statically, but some cases (e.g. to ensure the popup doesn\\u2019t go offscreen) may require dynamic fine-tuning. There is no return value: it\\u2019s assumed that you\\u2019ll either directly set the popup\\u2019s styles, or that you can use something in the callback\\u2019s closure to set the styles indirectly.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"focusControl\"), \" is used to determine how focus is handled when the popup is visible. The first parameter is the popup div, and the second is an object containing \\u201Csearch state\\u201D:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function focusControl(popupDiv: HTMLElement, searchState: {\\n  focusHint: string | number; // Described in the \\\"Update State\\\" section\\n  focusIndex: number; // The array index of the element that was focused last\\n  shift: boolean; // Described in the \\\"Update State\\\" section\\n}): HTMLElement[] | HTMLElement | undefined;\\n\")), mdx(\"p\", null, \"There are three basic ways the control can be used:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Return an array of focusable elements, and the element to be focused will be selected for you based on the focusHint; the default \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"focusControl\"), \" does this, returning all \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"tab-focusable\"), \" elements within the popup\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Return a single HTMLElement to be focused; modifications made to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"searchState.focusIndex\"), \" will be preserved to the next call\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Return undefined, which will result in no element being focused\")), mdx(\"p\", null, \"Using the default focusControl for example, if the popup is toggled to visible using the keyboard (or by clicking when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"focusOnClickExpand=true\"), \"), focus will automatically move to the first tab-focusable element in the popup.\"), mdx(\"p\", null, \"Because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"focusControl\"), \" is a required argument to an underlying function, to disable control entirely you should pass a no-op function, rather than null or undefined.\"), mdx(\"h3\", null, \"Return Value\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"usePopup\"), \" hook returns a single object with several properties:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Property\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"expanded\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The current visibilty state of the popup\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"toggle\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"function\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"A function used to control visibility & focus\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"setFocus\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"function\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"A function used to control focus\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"wrapperProps\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"object\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Props for the wrapper component\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"buttonProps\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"object\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Props for the button component\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"popupProps\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"object\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Props for the popup component\")))), mdx(\"p\", null, \"The props all contain convenient defaults, but you can change or remove them on a case-by-case basis if needed.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wrapperProps\"), \" contains:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"id\"), \" that was passed in with the options\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"role=\\u201Cnone\\u201D, so screen readers know the wrapper is purely structural\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onBlur\"), \" handler that closes the popup when focus is outside the wrapper\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tabIndex=-1, necessary for the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onBlur\"), \" handler to work on Safari, which doesn\\u2019t focus buttons on click\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onKeyDown\"), \" handler that closes the popup when the \", \"<\", \"Escape\", \">\", \" key is pressed\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"buttonProps\"), \" contains:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"id=\", \"[?]\", \" either the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"buttonId\"), \" option, or a generated ID; this \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"must\"), \" be set on the button for the default event handlers and the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"positionPopup\"), \" callback to work\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"role=\\u201Cbutton\\u201D\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"aria-haspopup=\", \"[popupType]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"aria-controls=\", \"[popupId]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"aria-expanded=\\u201Ctrue\\u201D if the popup is visible, `undefined if it\\u2019s hidden\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onClick\"), \" handler that toggles the popup\\u2019s visibility\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onKeyDown\"), \" handler that toggles the popup\\u2019s visibility when \", \"<\", \"Enter\", \">\", \" or \", \"<\", \"Space\", \">\", \" is pressed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onKeyUp\"), \" handler that calls \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"event.preventDefault()\"), \" when \", \"<\", \"Enter\", \">\", \" or \", \"<\", \"Space\", \">\", \" is pressed (because HTML button elements treat those two keys as a \\u201Cclick\\u201D event; onKeyDown toggles the popup to visible and then onClick toggles it off again)\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"popupProps\"), \" contains:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"id=\", \"[?]\", \" either the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"popupId\"), \" option, or a generated ID; this \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"must\"), \" be set on the popup for focus control and the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"positionPopup\"), \" callback to work\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tabIndex=-1, helps the wrapper\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onBlur\"), \" handler work better, and keeps the popup out of the tab order if it has a scroll bar\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"role=\", \"[popupType]\", \", matches the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"aria-haspopup\"), \" on the buttonProps\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"aria-labelledby=\", \"[buttonId]\", \"; by default, the label on the button is used to label the popup as well\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"aria-hidden=\\u201Ctrue\\u201D if the popup is hidden, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"undefined\"), \" if it\\u2019s visible\")), mdx(\"h4\", null, \"Update State: \", mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"toggle\"), \" & \", mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"setFocus\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"toggle\"), \" is used to change the visibility of the popup. Called with no arguments (or the first argument as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \"), it\\u2019s a normal toggle: on to off, off to on. You can also pass a boolean indicating what the new state should be (true = visible), in which case it will only update if the new state is different from the current state.\"), mdx(\"p\", null, \"For convenience, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"toggle\"), \" also accepts second and third arguments, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"focusHint\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"focusOpts\"), \", corresponding to the arguments for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFocus\"), \". Setting the focus through \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"toggle\"), \" has some advantages: if the popup is being opened, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"delay\"), \" option is automatically set so the popup has time to become visible before attempting to set the focus; and if the popup is closed, numeric/string focus hints are automatically changed to null since they can\\u2019t be calculated on hidden elements.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"toggle(true, focusHint, { ...focusOpts })\\n\")), mdx(\"p\", null, \"If you need to control the focus without changing the visibility, you can call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFocus\"), \" directly. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"focusHint\"), \" should be one of the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An HTMLElement object that should receive focus; this unsets the current focus index\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A number, which is either an index into the array returned by the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"focusControl\"), \" callback, or an offset from the current array index (see \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"shift\"), \" option)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A string, which can be used to search the text contents of the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"focusControl\"), \" array elements and focus on the first match\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"null, which unsets the current focus index\")), mdx(\"p\", null, \"There are also three options:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"delay\"), \" - if true, the element will be focused in a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useEffect\"), \" hook; with false (the default), the element is focused immediately\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"shift\"), \" - if true, indicates that a numeric \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"focusHint\"), \" is an offset in the focus control array from the currently-focused element (e.g. -1 would be analagous to pressing shift+tab); false (the default) indicates an absolute array index (e.g. -1 would focus on the last element in the array, regardless of the current focus)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"focusControl\"), \" - override the default focus control callback for just this update\")));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"title":"Hooks","slug":"/components/hooks/"}}},"pageContext":{"slug":"/components/hooks/"}},"staticQueryHashes":["3276690975"]}