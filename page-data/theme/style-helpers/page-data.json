{"componentChunkName":"component---src-templates-generic-template-tsx","path":"/theme/style-helpers/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Style Helpers\",\n  \"order\": -99\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Style Helpers\"), mdx(\"p\", null, \"Accessing theme properties from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"styled-components\"), \" styles is not difficult, but can involve a lot of boilerplate; after the tenth time you write something like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${(p) => p.theme.space[3]}\"), \" you start to want to refactor. The helpers defined in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@repay/cactus-theme\"), \" can help reduce that boilerplate, as well as provide logical help around some of the less common properties (like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boxShadows\"), \").\"), mdx(\"h3\", null, \"Usage\"), mdx(\"p\", null, \"All the helper functions (with the exception of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isResponsiveTouchDevice\"), \") have two call modes. When called in \\u201Cbinding\\u201D mode you pass the normal arguments, and it returns a function that takes in theme props (an object with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme\"), \" property) and returns the result. In the other call mode, you pass the theme props as the first argument, then the regular arguments, and it directly returns the results. These four are all the same:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const Sample = styled.div`\\n  margin: ${space(3)};\\n  margin: ${(p) => space(3)(p)};\\n  margin: ${(p) => space(p, 3)};\\n  margin: ${(p) => p.theme.space[3]}px;\\n`\\n\")), mdx(\"p\", null, \"Binding mode is the most common since it\\u2019s concise and compatible with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"styled-components\"), \"; the other mode mostly exists to make it possible to compose several helpers into a single function call.\"), mdx(\"h2\", null, \"Space/Sizes\"), mdx(\"h4\", null, \"space\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function space(index: number): '[number]px';\\n\")), mdx(\"p\", null, \"Indexes into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.space\"), \" array, and returns the result as a pixel length (e.g \\u20184px\\u2019).\"), mdx(\"h4\", null, \"iconSize\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function iconSize(size: keyof IconSizes): '[number]px;\\n\")), mdx(\"p\", null, \"Returns the value from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.iconSizes\"), \" object as a pixel length.\"), mdx(\"h4\", null, \"fontSize\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function fontSize(size: keyof FontSizes): 'font-size: [number]px;' | `\\n  font-size: [number]px;\\n  @media screen and (min-width: [medium breakpoint]) {\\n    font-size: [number]px;\\n  }\\n`;\\n\")), mdx(\"p\", null, \"Returns values from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.fontSizes\"), \" & \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.mobileFontSizes\"), \" objects. If the values are the same, returns a single property e.g. \\u201Cfont-size: 15px;\\u201C. If the values are different, returns a CSS block with a media query.\"), mdx(\"h4\", null, \"textStyle\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function textStyle(size: keyof TextStyles): {\\n  fontSize: '[number]px',\\n  lineHeight: [number],\\n} | `\\n  font-size: [number]px;\\n  line-height: [number];\\n  @media screen and (min-width: [medium breakpoint]) {\\n    font-size: [number]px;\\n    line-height: [number];\\n  }\\n`;\\n\")), mdx(\"p\", null, \"Returns values from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.textStyles\"), \" & \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.mobileTextStyles\"), \" objects. If the values are the same, returns the value (which is an object with keys \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fontSize\"), \" & \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lineHeight\"), \"). If the values are different, returns a CSS block with a media query.\"), mdx(\"h4\", null, \"lineHeight\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"type RenderFunc = (lineHeight: string, p: ThemeProps) => string\\nfunction lineHeight(\\n  size: keyof TextStyles,\\n  prop: string | RenderFunc,\\n  type: 'px' | 'em' = 'px'\\n): string;\\n\")), mdx(\"p\", null, \"Returns a CSS property or block calculated from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.textStyles\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.mobileTextStyles\"), \". The value is calculated as a pixel length by default (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lineHeight * fontSize\"), \"), but you can also get the value in em units. There are two ways to render: specify the name of the CSS property, or pass a function to do the rendering. In both cases, if the calculated value is different for mobile & regular styles, the output is turned into a CSS block with a media query, similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fontSize\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"textStyle\"), \".\"), mdx(\"h2\", null, \"Colors\"), mdx(\"h4\", null, \"color\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function color(colorName: keyof Colors): ColorValue;\\n\")), mdx(\"p\", null, \"Returns a value from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.colors\"), \" object.\"), mdx(\"h4\", null, \"colorStyle\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"type ColorStyle = { color: ColorValue; backgroundColor: ColorValue }\\nfunction colorStyle(styleName: keyof ColorStyles): ColorStyle;\\nfunction colorStyle(foregroundColor: string, backgroundColor: string): ColorStyle;\\n\")), mdx(\"p\", null, \"This one can be used two ways. Called with a name from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.colorStyles\"), \" object, it will return the value from the theme. Called with two arguments, it will return a custom style with the given colors: each color can either be a browser-recognized color value, or a name from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.colors\"), \" object.\"), mdx(\"h2\", null, \"Borders\"), mdx(\"h4\", null, \"borderSize\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const BORDER_SIZE = { thin: '1px', thick: '2px' }\\nfunction borderSize(opts: { thin: unknown; thick: unknown } = BORDER_SIZE): unknown;\\n\")), mdx(\"p\", null, \"Returns a value from the opts argument depending on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.border\"), \" setting. When called with no arguments, returns the default border thickness.\"), mdx(\"h4\", null, \"border\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"type Opts = { thin?: string; thick?: string }\\nfunction border(color: string, opts?: Opts): '[thickness] solid [color]';\\n\")), mdx(\"p\", null, \"Returns a CSS value appropriate for use with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"border\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"outline\"), \" properties, e.g. \\u201C1px solid black\\u201D. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"color\"), \" can be any color string recognized by browsers, or the name of a color in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.colors\"), \". Both keys in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"opts\"), \" object are optional, so you can override just one of the border thicknesses if you want to use the default for the other.\"), mdx(\"h4\", null, \"radius\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function radius(maxRadius: number, intermediateScaleFactor = 0.4): '[number]px';\\n\")), mdx(\"p\", null, \"Returns a radius scaled according to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.shape\"), \" setting: for \\u201Csquare\\u201D the radius is always \\u201C0px\\u201D (scale factor 0), and for \\u201Cround\\u201D it\\u2019s the number you passed in (scale factor 1). In addition, the result of the scale operation is passed through \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.ceil\"), \", so calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"radius(8)\"), \" will do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.ceil(8*.4[=3.2])[=4]px\"), \".\"), mdx(\"h4\", null, \"insetBorder\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"type Direction = 'top' | 'bottom' | 'left' | 'right'\\ntype Opts = { thin?: string; thick?: string }\\nfunction insetBorder(color: string, dir?: Direction, opts?: Opts): 'box-shadow: inset [size] [color]';\\n\")), mdx(\"p\", null, \"Returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"box-shadow\"), \" CSS property for a solid inset border. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"color\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"opts\"), \" arguments behave the same way they do in the regular \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"border\"), \" function. If a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"direction\"), \" is specified, the border will only appear on the specified side, otherwise it will be on all four sides.\"), mdx(\"p\", null, \"Obviously this can\\u2019t be used alongside a regular box shadow property, but inset borders are useful in situations where you want to add a visual border without affecting the layout (since a normal border takes up space between the margins and padding).\"), mdx(\"h2\", null, \"Shadows\"), mdx(\"p\", null, \"The REPAY style guide defines several box shadow \\u201Ctypes\\u201D, which are numbered 0-5. Though these are technically unrelated to either the theme or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"styled-component\"), \", they are often used in conjunction with other properties so it\\u2019s well worth adding helpers for them.\"), mdx(\"h4\", null, \"boxShadow\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function boxShadow(shadowType: number, color: string = 'lightCallToAction'): 'box-shadow: [size] [color]';\\n\")), mdx(\"p\", null, \"Returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"box-shadow\"), \" CSS property with the given type. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"color\"), \" can be a browser-recognized color value, or a name from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.colors\"), \"; it defaults to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.colors.lightCallToAction\"), \".\"), mdx(\"h4\", null, \"shadow\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"type Shadow = string | CSSObject | undefined\\nfunction shadow(shadowTypeOrSize: number | string, fallback?: Shadow | (props) => Shadow): Shadow;\\n\")), mdx(\"p\", null, \"Similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boxShadow\"), \", except it only returns the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"box-shadow\"), \" property if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.boxShadows\"), \" is true and the color can\\u2019t be customized. You can also pass a custom shadow size if needed, rather than being restricted to the predefined types from the style guide.\"), mdx(\"p\", null, \"If \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.boxShadows\"), \" is false, the fallback is returned instead:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"fallback\"), \" is a function, it is called with the theme props as the only argument.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"fallback\"), \" is a string with no \\u201D:\\u201D, it is passed to the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"border\"), \" helper as a color.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"fallback\"), \" or the result of previous steps is a string with no \\u201D:\\u201D, it is returned as a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"border\"), \" CSS property.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Else it\\u2019s returned as-is.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"shadow(0, 'lightContrast') // = 'border: 1px solid [theme.colors.lightContrast]'\\nshadow(0, border('red', { thin: '2px' })) // = 'border: 2px solid red'\\nshadow(0, 'outline: 1px solid green') // = 'outline: 1px solid green'\\nshadow(0, { margin: '2px' }) // = { margin: '2px' }\\n\")), mdx(\"h2\", null, \"Breakpoints\"), mdx(\"h4\", null, \"mediaGTE\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function mediaGTE(breakpoint: keyof Breakpoints): '@media (min-width: [breakpoint])';\\n\")), mdx(\"p\", null, \"Returns a min-width media query for the given breakpoint, similar to the kind used by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"styled-system\"), \". (The GTE indicates \\u201Cgreater than or equal to\\u201D, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mediaGTE('small')\"), \" matches all widths greater than or equal to the small breakpoint.)\"), mdx(\"h4\", null, \"mediaLT\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function mediaLT(breakpoint: keyof Breakpoints): '@media (max-width: [breakpoint])';\\n\")), mdx(\"p\", null, \"Returns a max-width media query for the given breakpoint (technically it\\u2019s a \\u201Cnot (min-width: \\u2026)\\u201D query, which is why the function is called \\u201Cless than\\u201D and not \\u201Cless than or equal to\\u201D).\"), mdx(\"h4\", null, \"breakpoint\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function breakpoint(breakpoint: number | keyof Breakpoints): '[breakpoint]'\\n\")), mdx(\"p\", null, \"Returns the given value from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.breakpoints\"), \". Since that\\u2019s an array rather than an object you can pass an array index, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"breakpoint(0)\"), \" for the first breakpoint, but you can also use the names from the media queries, e.g. `breakpoint(\\u2018small\\u2019).\"), mdx(\"h2\", null, \"Special\"), mdx(\"h4\", null, \"isResponsiveTouchDevice\"), mdx(\"p\", null, \"Returns true if the code is running on a touch-enabled device with a \\u201Ctiny\\u201D screen size (width < \\u201Csmall\\u201D breakpoint), and whose screen is the same width as the window; e.g. a smart phone or small tablet.\"), mdx(\"p\", null, \"This one is special in that it\\u2019s only incidentally related to the theme (it uses the first breakpoint), and it doesn\\u2019t do the argument currying that the others do: because it returns a boolean it must always be used in a block with other statements, so there would be no value in being able to throw \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${isResponsiveTouchDevice()}\"), \" in your styles.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const StyledDifferentlyOnMobile = styled.div`\\n  ${(p) => isResponsiveTouchDevice(p) ? mobileStyles : regularStyles};\\n`\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"title":"Style Helpers","slug":"/theme/style-helpers/"}}},"pageContext":{"slug":"/theme/style-helpers/"}},"staticQueryHashes":["3276690975"]}